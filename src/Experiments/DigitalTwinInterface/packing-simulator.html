<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Truck Simulator - Final Configurable</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #info {
            position: absolute; top: 10px; left: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px; border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15); width: 260px;
            user-select: none;
        }
        h3 { margin-top: 0; margin-bottom: 10px; color: #333; }
        label { font-size: 0.85em; font-weight: bold; color: #555; display: block; margin-top: 10px; margin-bottom: 3px;}
        select {
            width: 100%; padding: 8px; 
            border-radius: 4px; border: 1px solid #ccc; font-size: 14px;
        }
        button {
            display: block; margin-top: 8px; padding: 10px;
            cursor: pointer; width: 100%;
            background-color: #007bff; color: white;
            border: none; border-radius: 4px; font-weight: bold; transition: background 0.2s;
        }
        button:hover { background-color: #0056b3; }
        .row { display: flex; gap: 5px; margin-top: 5px; }
        .btn-action { background-color: #6c757d; font-size: 0.9em; padding: 8px; color: white; border: none; border-radius: 4px; cursor: pointer; flex: 1;}
        .btn-action:hover { background-color: #5a6268; }
        
        #btnDelete { background-color: #ff9800; color: white; } /* Orange for single delete */
        #btnDelete:hover { background-color: #e68900; }
        
        #btnClear { background-color: #dc3545; margin-top: 15px; } /* Red for clear all */
        #btnClear:hover { background-color: #c82333; }
        
        .stats { margin-top: 15px; font-size: 0.9em; color: #333; border-top: 1px solid #ddd; padding-top: 10px;}
        .hint { font-size: 0.8em; color: #666; margin-bottom: 10px; font-style: italic;}
        .error { color: #d9534f; font-size: 0.85em; margin-top: 5px; min-height: 1.2em; font-weight: bold;}
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="info">
        <h3>Truck Loader</h3>
        
        <label>Select Truck Size</label>
        <select id="truckSelector"></select>

        <label>Select Item to Load</label>
        <select id="itemSelector"></select>

        <button id="btnAdd">Add Item</button>
        
        <div class="row">
            <button class="btn-action" id="btnSpin">Spin (R)</button>
            <button class="btn-action" id="btnStand">Stand (T)</button>
        </div>
        
        <button id="btnDelete">Delete Selected (Del)</button>
        <button id="btnClear">Clear All</button>
        
        <div class="error" id="errorText"></div>
        <div class="stats" id="statusText">Items: 0 | Vol: 0%</div>
        <div class="hint" style="margin-top:5px;">Left Click: Select/Drag | Right: Pan</div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // ==========================================
        //       USER CONFIGURATION ZONE
        // ==========================================

        const CONFIG = {
            GAP: 5, // Gap between boxes in cm

            // DEFINE YOUR TRUCKS (cm)
            TRUCKS: [
                { id: 't_20ft', name: '20ft Container', w: 235, h: 239, d: 590 },
                { id: 't_17ft', name: '17ft Truck',     w: 215, h: 220, d: 520 },
                { id: 't_14ft', name: '14ft Truck',     w: 210, h: 210, d: 430 },
                { id: 't_10ft', name: '10ft Mini',      w: 175, h: 185, d: 305 },
            ],

            // DEFINE YOUR ITEMS (cm)
            ITEMS: [
                // Boxes
                { id: 'box_s', cat: 'Boxes', name: 'Small Box',  w: 30, h: 30, d: 30, color: 0x4CAF50 },
                { id: 'box_m', cat: 'Boxes', name: 'Medium Box', w: 45, h: 45, d: 45, color: 0xFFC107 },
                { id: 'box_l', cat: 'Boxes', name: 'Large Box',  w: 60, h: 60, d: 60, color: 0xFF5722 },
                { id: 'box_xl', cat: 'Boxes', name: 'XL Carton',  w: 75, h: 75, d: 75, color: 0xB71C1C },

                // Furniture
                { id: 'bed_q',    cat: 'Furniture', name: 'Queen Mattress', w: 152, h: 25,  d: 203, color: 0xFFFFF0 },
                { id: 'bed_k',    cat: 'Furniture', name: 'King Mattress',  w: 193, h: 25,  d: 203, color: 0xF0E68C },
                { id: 'sofa',     cat: 'Furniture', name: '3-Seater Sofa',  w: 220, h: 85,  d: 90,  color: 0x8B4513 },
                { id: 'wardrobe', cat: 'Furniture', name: 'Wardrobe',       w: 60,  h: 180, d: 60,  color: 0xDEB887 },
                { id: 'table',    cat: 'Furniture', name: 'Dining Table',   w: 150, h: 75,  d: 90,  color: 0x8B0000 },
                
                // Appliances
                { id: 'fridge', cat: 'Appliances', name: 'Fridge',          w: 70, h: 170, d: 70, color: 0xA9A9A9 },
                { id: 'wash',   cat: 'Appliances', name: 'Washing Machine', w: 60, h: 85,  d: 60, color: 0xF0F8FF },
                { id: 'ac',     cat: 'Appliances', name: 'AC Outdoor Unit', w: 80, h: 55,  d: 30, color: 0xE0E0E0 },
            ]
        };

        // ==========================================
        //        CORE ENGINE
        // ==========================================

        let currentTruck = { ...CONFIG.TRUCKS[0] }; 
        const items = []; 
        let isDragging = false;
        let selectedItem = null;
        
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 5000);
        camera.position.set(0, 600, 800);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(200, 500, 300);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- DYNAMIC UI ---
        function initUI() {
            const truckSel = document.getElementById('truckSelector');
            CONFIG.TRUCKS.forEach((t, index) => {
                const opt = document.createElement('option');
                opt.value = index; 
                opt.textContent = t.name;
                truckSel.appendChild(opt);
            });

            const itemSel = document.getElementById('itemSelector');
            const groups = {};
            CONFIG.ITEMS.forEach((item, index) => {
                if (!groups[item.cat]) {
                    const grp = document.createElement('optgroup');
                    grp.label = item.cat;
                    groups[item.cat] = grp;
                    itemSel.appendChild(grp);
                }
                const opt = document.createElement('option');
                opt.value = index; 
                opt.textContent = item.name;
                groups[item.cat].appendChild(opt);
            });
        }
        initUI();

        // --- TRUCK MESH ---
        let truckMeshGroup = new THREE.Group();
        scene.add(truckMeshGroup);

        function buildTruck(dims) {
            while(truckMeshGroup.children.length > 0){ 
                const obj = truckMeshGroup.children[0];
                if(obj.geometry) obj.geometry.dispose();
                if(obj.material) obj.material.dispose();
                truckMeshGroup.remove(obj); 
            }
            const floorGeo = new THREE.PlaneGeometry(dims.w, dims.d);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0xdddddd, side: THREE.DoubleSide });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            truckMeshGroup.add(floor);

            const boxGeo = new THREE.BoxGeometry(dims.w, dims.h, dims.d);
            const edges = new THREE.EdgesGeometry(boxGeo);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x333333 }));
            line.position.y = dims.h / 2; 
            truckMeshGroup.add(line);
        }
        buildTruck(currentTruck);

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        const planeIntersect = new THREE.Vector3();

        function showError(msg) {
            const el = document.getElementById('errorText');
            el.innerText = msg;
            setTimeout(() => el.innerText = "", 2000);
        }

        // --- COLLISION ---
        function checkOverlap(boxA, posA, boxB, posB, gap = 0) {
            const wa = boxA.width/2; const da = boxA.depth/2;
            const wb = boxB.width/2; const db = boxB.depth/2;
            return Math.abs(posA.x - posB.x) < (wa + wb) + gap - 0.1 &&
                   Math.abs(posA.z - posB.z) < (da + db) + gap - 0.1;
        }

        function check3DCollision(boxA, posA, boxB, posB, gap = 0) {
            const ha = boxA.height/2; const hb = boxB.height/2;
            const overlapY = Math.abs(posA.y - posB.y) < (ha + hb) - 0.1; 
            return checkOverlap(boxA, posA, boxB, posB, gap) && overlapY;
        }

        function isSpaceOccupied(width, height, depth, x, y, z, gap, ignoreItem = null) {
            const newParams = { width, height, depth };
            const newPos = { x, y, z };
            for (let item of items) {
                if (item === ignoreItem) continue;
                if (check3DCollision(newParams, newPos, item.geometry.parameters, item.position, gap)) {
                    return true;
                }
            }
            return false;
        }

        // --- ROTATION & DELETION ---
        function performRotation(type) {
            if (!selectedItem) { showError("Select an item first!"); return; }
            const p = selectedItem.geometry.parameters;
            const oldW = p.width; const oldH = p.height; const oldD = p.depth;
            let newW, newH, newD;

            if (type === 'spin') { newW = oldD; newH = oldH; newD = oldW; } 
            else if (type === 'stand') { newW = oldH; newH = oldW; newD = oldD; }

            if (selectedItem.position.y - (oldH/2) + newH > currentTruck.h) {
                showError("Too tall!"); return;
            }
            const newGeo = new THREE.BoxGeometry(newW, newH, newD);
            selectedItem.geometry.dispose();
            selectedItem.geometry = newGeo;
            selectedItem.children[0].geometry.dispose();
            selectedItem.children[0].geometry = new THREE.EdgesGeometry(newGeo);
            updateDragPosition(selectedItem, selectedItem.position.x, selectedItem.position.z);
            updateStatus();
        }

        function deleteSelectedItem() {
            if (!selectedItem) {
                showError("Select item to delete!");
                return;
            }
            // Remove from Scene
            scene.remove(selectedItem);
            
            // Remove from Array
            const index = items.indexOf(selectedItem);
            if (index > -1) items.splice(index, 1);
            
            selectedItem = null;
            isDragging = false;
            updateStatus();
        }

        // --- DRAGGING ---
        function constrainToBounds(item, val, axis) {
            const size = axis === 'x' ? item.geometry.parameters.width : item.geometry.parameters.depth;
            const limit = (axis === 'x' ? currentTruck.w : currentTruck.d) / 2 - size / 2;
            return Math.max(-limit, Math.min(limit, val));
        }

        function updateDragPosition(targetItem, targetX, targetZ) {
            const safeX = constrainToBounds(targetItem, targetX, 'x');
            const safeZ = constrainToBounds(targetItem, targetZ, 'z');
            const w = targetItem.geometry.parameters.width;
            const d = targetItem.geometry.parameters.depth;
            const h = targetItem.geometry.parameters.height;

            let highestY = 0; 
            items.forEach(other => {
                if (other === targetItem) return;
                if (checkOverlap({width:w, depth:d}, {x:safeX, z:safeZ}, 
                                 other.geometry.parameters, other.position, -1)) {
                    const topOfOther = other.position.y + other.geometry.parameters.height/2;
                    if (topOfOther > highestY) highestY = topOfOther;
                }
            });

            if ((highestY + h) > currentTruck.h) return; 
            targetItem.position.set(safeX, highestY + h/2, safeZ);
        }

        // --- FINDING SLOT ---
        function findNextSlot(w, h, d) {
            const step = 20; 
            const gap = CONFIG.GAP;
            for (let y = h/2; y < currentTruck.h; y += step) {
                const zStart = -(currentTruck.d / 2) + (d / 2) + gap;
                const zEnd = (currentTruck.d / 2) - (d / 2) - gap;
                for (let z = zStart; z <= zEnd; z += step) {
                    const xStart = -(currentTruck.w / 2) + (w / 2) + gap;
                    const xEnd = (currentTruck.w / 2) - (w / 2) - gap;
                    for (let x = xStart; x <= xEnd; x += step) {
                        if (!isSpaceOccupied(w, h, d, x, y, z, gap)) {
                            if (y + h/2 > currentTruck.h) continue;
                            if (y > h) {
                                if (!isSpaceOccupied(w, h, d, x, y - h, z, 0)) continue; 
                            }
                            return { x, y, z };
                        }
                    }
                }
            }
            return null;
        }

        function addItem() {
            const idx = document.getElementById('itemSelector').value;
            const data = CONFIG.ITEMS[idx];
            const pos = findNextSlot(data.w, data.h, data.d);
            if (!pos) { showError("Truck Full!"); return; }

            const geometry = new THREE.BoxGeometry(data.w, data.h, data.d);
            const material = new THREE.MeshStandardMaterial({ color: data.color });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(pos.x, pos.y, pos.z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;

            const borderGeo = new THREE.EdgesGeometry(geometry);
            const borderMat = new THREE.LineBasicMaterial({ color: 0x000000 });
            const wireframe = new THREE.LineSegments(borderGeo, borderMat);
            mesh.add(wireframe);

            scene.add(mesh);
            items.push(mesh);
            updateStatus();
        }

        function clearTruck() {
            items.forEach(item => scene.remove(item));
            items.length = 0;
            selectedItem = null;
            updateStatus();
        }

        function changeTruckSize() {
            const idx = document.getElementById('truckSelector').value;
            currentTruck = { ...CONFIG.TRUCKS[idx] };
            clearTruck();
            buildTruck(currentTruck);
            updateStatus();
        }

        function updateStatus() {
            let totalVol = 0;
            items.forEach(i => {
                const p = i.geometry.parameters;
                totalVol += (p.width * p.height * p.depth);
            });
            const truckVol = currentTruck.w * currentTruck.h * currentTruck.d;
            const percent = ((totalVol / truckVol) * 100).toFixed(1);
            document.getElementById('statusText').innerText = `Items: ${items.length} | Vol: ${percent}%`;
        }

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; 
        controls.zoomSpeed = 3.0;

        window.addEventListener('mousedown', (event) => {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(items, true);
            if (selectedItem) selectedItem.material.emissive.set(0x000000);

            if (intersects.length > 0) {
                let obj = intersects[0].object;
                if (obj.type === 'LineSegments') obj = obj.parent;
                controls.enabled = false;
                isDragging = true;
                selectedItem = obj;
                selectedItem.material.emissive.set(0x999999);
            } else {
                selectedItem = null; 
            }
        });

        window.addEventListener('mousemove', (event) => {
            if (!isDragging || !selectedItem) return;
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            raycaster.ray.intersectPlane(dragPlane, planeIntersect);

            if (planeIntersect) {
                updateDragPosition(selectedItem, planeIntersect.x, planeIntersect.z);
            }
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
            controls.enabled = true;
        });

        window.addEventListener('keydown', (e) => {
            const k = e.key.toLowerCase();
            if (k === 'r') performRotation('spin');
            if (k === 't') performRotation('stand');
            if (e.key === 'Delete' || e.key === 'Backspace') deleteSelectedItem();
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        document.getElementById('btnAdd').addEventListener('click', addItem);
        document.getElementById('btnClear').addEventListener('click', clearTruck);
        document.getElementById('btnDelete').addEventListener('click', deleteSelectedItem);
        document.getElementById('truckSelector').addEventListener('change', changeTruckSize);
        document.getElementById('btnSpin').addEventListener('click', () => performRotation('spin'));
        document.getElementById('btnStand').addEventListener('click', () => performRotation('stand'));

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>